#include <nds.h>
#include "gl2d.h"

#include "graphics/fontHandler.h"
#include "graphics/graphics.h"
#include "sound.h"

#include "player.h"

#include "bottomImage.h"
#include "spr_aimbutton.h"
#include "tiles.h"
#include "tilenum.h"

#include "testmap.h"
#include "level_kglf.h"

#define bgTile 11
#define grayBlockTile 17

extern bool wideScreen;
extern bool fadeType;

static bool inited = false;

int mapHsize = 32;
int mapVsize = 24;

int cameraXpos = 0;
int cameraYpos = 0;

u8 mapData[32*27] = {7};

extern int playerX[2], playerY[2];

static int tileTexID;
glImage tileImage[(128 / 16) * (128 / 16)];

void levelGraphicLoad(void) {
	tileTexID = glLoadTileSet(tileImage, // pointer to glImage array
							16, // sprite width
							16, // sprite height
							128, // bitmap width
							128, // bitmap height
							GL_RGB256, // texture type for glTexImage2D() in videoGL.h
							TEXTURE_SIZE_128, // sizeX for glTexImage2D() in videoGL.h
							TEXTURE_SIZE_128, // sizeY for glTexImage2D() in videoGL.h
							GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
							256, // Length of the palette to use (16 colors)
							(u16*) tilesPal, // Load our 16 color tiles palette
							(u8*) tilesBitmap // image data generated by GRIT
							);
}

bool isSolidTile(u8 tile) {
	switch (tile) {
		case 0:
		case 4:
		case 5:
		case 6:
		case 8:
		case 13:
		case 16:
		case 17:
		case 20:
		case 21:
		case 24:
		case 25:
		case 28:
		case 29:
		case 33:
		case 34:
		case 35:
		case 36:
		case 37:
		case 40:
		case 41:
		case 42:
		case 43:
		case 44:
		case 45:
			return true;
		default:
			break;
	}
	return false;
}

void loadLevel(u8* orgMapData) {
	mapHsize = -1;
	mapVsize = -1;
	memset(mapData, 7, sizeof(mapData));

	bool mapHsizeSet = false;
	bool processTile = false;
	int generatedPlayerX = -16;
	int i1 = -1;	// Position in generated map
	int i2 = -1;	// Position in kglf file
	while (1) {
		if (orgMapData[i2] == 'E' && orgMapData[i2+1] == 'N' && orgMapData[i2+2] == 'D') {
			break;
		} else if (orgMapData[i2] == 0x0D && orgMapData[i2+1] == 0x0A) {
			i2++;
			mapVsize++;
			generatedPlayerX = -16;
			mapHsizeSet = true;
		} else if (orgMapData[i2] == 0x0A) {
			mapVsize++;
			generatedPlayerX = -16;
			mapHsizeSet = true;
		} else {
			i1++;
			processTile = true;
		}
		generatedPlayerX += 16;
		i2++;
		if (!mapHsizeSet) {
			mapHsize++;
		}
		if (orgMapData[i2] == '1') {
			setPlayerPosition(0, generatedPlayerX, (mapVsize*16)-16);
		} else
		if (processTile) {
			for (int i3 = 0; i3 < (int)sizeof(textTiles); i3++) {
				if (textTiles[i3] == orgMapData[i2]) {
					mapData[i1] = i3;
					break;
				}
			}
			processTile = false;
		}
	}
}

void levelMode(void) {
	if (!inited) {
		loadLevel(level_kglf);

		//setPlayerPosition(0, testMap_player1X, testMap_player1Y);
		setPlayerPosition(1, testMap_player2X, testMap_player2Y);

		playerGraphicLoad();
		decompress(bottomImageBitmap, bgGetGfxPtr(bg3), LZ77Vram);
		bgSetScroll(bg3, 0, 0);
		bgScroll(bg3, 0, 0);
		oamClear(&oamSub, 0, 2);

		gfxSub = oamAllocateGfx(&oamSub, SpriteSize_32x64, SpriteColorFormat_16Color);

		memcpy(gfxSub, spr_aimbuttonTiles, spr_aimbuttonTilesLen);

		for (int i = 0; i < 16; i++) {
			SPRITE_PALETTE_SUB[i] = spr_aimbuttonPal[i];
		}

		oamSet(&oamSub, 
			0, 
			80, 48, 
			0, 
			0,
			SpriteSize_32x32, 
			SpriteColorFormat_16Color, 
			gfxSub+(32*8), 
			-1, 
			false, 
			false,	
			false, false, 
			false
			);

		oamSet(&oamSub, 
			1, 
			112, 48, 
			0, 
			0,
			SpriteSize_32x32, 
			SpriteColorFormat_16Color, 
			gfxSub, 
			-1, 
			false, 
			false,	
			false, false, 
			false
			);

		oamSet(&oamSub, 
			2, 
			144, 48, 
			0, 
			0,
			SpriteSize_32x32, 
			SpriteColorFormat_16Color, 
			gfxSub+(32*8), 
			-1, 
			false, 
			false,	
			true, false, 
			false
			);

		oamSet(&oamSub, 
			3, 
			80, 80, 
			0, 
			0,
			SpriteSize_32x32, 
			SpriteColorFormat_16Color, 
			gfxSub+(64*8), 
			-1, 
			false, 
			false,	
			false, false, 
			false
			);

		oamSet(&oamSub, 
			4, 
			144, 80, 
			0, 
			0,
			SpriteSize_32x32, 
			SpriteColorFormat_16Color, 
			gfxSub+(64*8), 
			-1, 
			false, 
			false,	
			true, false, 
			false
			);

		oamSet(&oamSub, 
			5, 
			80, 112, 
			0, 
			0,
			SpriteSize_32x32, 
			SpriteColorFormat_16Color, 
			gfxSub+(32*8), 
			-1, 
			false, 
			false,	
			false, true, 
			false
			);

		oamSet(&oamSub, 
			6, 
			144, 112, 
			0, 
			0,
			SpriteSize_32x32, 
			SpriteColorFormat_16Color, 
			gfxSub+(32*8), 
			-1, 
			false, 
			false,	
			true, true, 
			false
			);

		fadeType = true;
		snd().loadStream("nitro:/music/tense.wav", true);
		snd().beginStream();
		inited = true;
	}

	scanKeys();
	int pressed = keysDown();
	int held = keysHeld();
	
	playerLoop(pressed, held);
}

void levelGraphicDisplay(void) {
	glBoxFilled(0, 0, (wideScreen ? 308 : 256), 192, RGB15(85/8, 85/8, 255/8));
	/*for (int x = 0; x < 256; x += 16) {
		for (int y = 0; y < 192; y += 16) {
			glSprite(x, y, GL_FLIP_NONE, &tileImage[bgTile]);
		}
	}*/
	//if (mapHsize>16 && playerX>(256/2)) {
		cameraXpos = playerX[0]-((wideScreen ? 308 : 256)/2);
	/*	if (cameraXpos > (mapHsize*16)-256) {
			cameraXpos = (mapHsize*16)-256;
		}
	} else {
		cameraXpos = 0;
	}*/
	//if (mapVsize>12 && playerY>192/2) {
		cameraYpos = playerY[0]-(192/2);
	/*	if (cameraYpos > (mapVsize*16)-192) {
			cameraYpos = (mapVsize*16)-192;
		}
	} else {
		cameraYpos = 0;
	}*/
	for (int x = 0; x < mapHsize; x++) {
		for (int y = 0; y < mapVsize; y++) {
			if (mapData[(y*mapHsize)+x] != 7) {
				glSprite((x*16)-cameraXpos, (y*16)-cameraYpos, GL_FLIP_NONE, &tileImage[mapData[(y*mapHsize)+x]]);
			}
		}
	}
	renderPlayer();
}
